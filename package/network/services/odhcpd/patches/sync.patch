--- a/README
+++ b/README
@@ -101,6 +101,9 @@ dhcpv6_na		bool	1			DHCPv6 stateful addr
 								Internet Address - Network Address
 dhcpv6_pd		bool	1			DHCPv6 stateful addressing hands out IA_PD -
 								Internet Address - Prefix Delegation
+dhcpv6_pd_min		integer	32			Minimum prefix length to delegate with IA_PD
+							(value is adjusted if needed to be greater
+							than the interface prefix length)
 router			list    <local address>		Routers to announce
 							accepts IPv4 only
 dns			list	<local address>		DNS servers to announce
@@ -142,6 +145,8 @@ ra_mtu			integer -			MTU to be advertise
 							RA messages
 ra_dns			bool	1			Announce DNS configuration in
 							RA messages (RFC8106)
+ra_pref64		string				Announce PREF64 option
+			[IPv6 prefix]			for NAT64 prefix (RFC8781)
 ndproxy_routing		bool	1			Learn routes from NDP
 ndproxy_slave		bool	0			NDProxy external slave
 prefix_filter		string	::/0			Only advertise on-link prefixes within
--- a/src/config.c
+++ b/src/config.c
@@ -39,6 +39,10 @@ struct config config = {.legacy = false,
 #define HOSTID_LEN_MAX	64
 #define HOSTID_LEN_DEFAULT HOSTID_LEN_MIN
 
+#define PD_MIN_DEFAULT 32 // will actually be clamped to the interface's prefix length + 1
+#define PD_MIN_LEN_MIN 32
+#define PD_MIN_LEN_MAX 64
+
 #define OAF_DHCPV6	(OAF_DHCPV6_NA | OAF_DHCPV6_PD)
 
 enum {
@@ -64,6 +68,7 @@ enum {
 	IFACE_ATTR_DHCPV6_RAW,
 	IFACE_ATTR_DHCPV6_ASSIGNALL,
 	IFACE_ATTR_DHCPV6_PD,
+	IFACE_ATTR_DHCPV6_PD_MIN,
 	IFACE_ATTR_DHCPV6_NA,
 	IFACE_ATTR_DHCPV6_HOSTID_LEN,
 	IFACE_ATTR_RA_DEFAULT,
@@ -82,6 +87,7 @@ enum {
 	IFACE_ATTR_RA_HOPLIMIT,
 	IFACE_ATTR_RA_MTU,
 	IFACE_ATTR_RA_DNS,
+	IFACE_ATTR_RA_PREF64,
 	IFACE_ATTR_PD_MANAGER,
 	IFACE_ATTR_PD_CER,
 	IFACE_ATTR_NDPROXY_ROUTING,
@@ -115,6 +121,7 @@ static const struct blobmsg_policy iface
 	[IFACE_ATTR_DHCPV6_RAW] = { .name = "dhcpv6_raw", .type = BLOBMSG_TYPE_STRING },
 	[IFACE_ATTR_DHCPV6_ASSIGNALL] = { .name ="dhcpv6_assignall", .type = BLOBMSG_TYPE_BOOL },
 	[IFACE_ATTR_DHCPV6_PD] = { .name = "dhcpv6_pd", .type = BLOBMSG_TYPE_BOOL },
+	[IFACE_ATTR_DHCPV6_PD_MIN] = { .name = "dhcpv6_pd_min", .type = BLOBMSG_TYPE_INT32 },
 	[IFACE_ATTR_DHCPV6_NA] = { .name = "dhcpv6_na", .type = BLOBMSG_TYPE_BOOL },
 	[IFACE_ATTR_DHCPV6_HOSTID_LEN] = { .name = "dhcpv6_hostidlength", .type = BLOBMSG_TYPE_INT32 },
 	[IFACE_ATTR_PD_MANAGER] = { .name = "pd_manager", .type = BLOBMSG_TYPE_STRING },
@@ -135,6 +142,7 @@ static const struct blobmsg_policy iface
 	[IFACE_ATTR_RA_HOPLIMIT] = { .name = "ra_hoplimit", .type = BLOBMSG_TYPE_INT32 },
 	[IFACE_ATTR_RA_MTU] = { .name = "ra_mtu", .type = BLOBMSG_TYPE_INT32 },
 	[IFACE_ATTR_RA_DNS] = { .name = "ra_dns", .type = BLOBMSG_TYPE_BOOL },
+	[IFACE_ATTR_RA_PREF64] = { .name = "ra_pref64", .type = BLOBMSG_TYPE_STRING },
 	[IFACE_ATTR_NDPROXY_ROUTING] = { .name = "ndproxy_routing", .type = BLOBMSG_TYPE_BOOL },
 	[IFACE_ATTR_NDPROXY_SLAVE] = { .name = "ndproxy_slave", .type = BLOBMSG_TYPE_BOOL },
 	[IFACE_ATTR_PREFIX_FILTER] = { .name = "prefix_filter", .type = BLOBMSG_TYPE_STRING },
@@ -212,6 +220,7 @@ static void set_interface_defaults(struc
 	iface->dhcpv4_end.s_addr = htonl(START_DEFAULT + LIMIT_DEFAULT - 1);
 	iface->dhcpv6_assignall = true;
 	iface->dhcpv6_pd = true;
+	iface->dhcpv6_pd_min = PD_MIN_DEFAULT;
 	iface->dhcpv6_na = true;
 	iface->dhcpv6_hostid_len = HOSTID_LEN_DEFAULT;
 	iface->dns_service = true;
@@ -849,6 +858,15 @@ int config_parse_interface(void *data, s
 	if ((c = tb[IFACE_ATTR_DHCPV6_PD]))
 		iface->dhcpv6_pd = blobmsg_get_bool(c);
 
+	if ((c = tb[IFACE_ATTR_DHCPV6_PD_MIN])) {
+		uint32_t pd_min_len = blobmsg_get_u32(c);
+		if (pd_min_len >= PD_MIN_LEN_MIN && pd_min_len <= PD_MIN_LEN_MAX)
+			iface->dhcpv6_pd_min = pd_min_len;
+		else
+			syslog(LOG_ERR, "Invalid %s value configured for interface '%s'",
+			       iface_attrs[IFACE_ATTR_DHCPV6_PD_MIN].name, iface->name);
+	}
+
 	if ((c = tb[IFACE_ATTR_DHCPV6_NA]))
 		iface->dhcpv6_na = blobmsg_get_bool(c);
 
@@ -958,6 +976,24 @@ int config_parse_interface(void *data, s
 	if ((c = tb[IFACE_ATTR_RA_DNS]))
 		iface->ra_dns = blobmsg_get_bool(c);
 
+	if ((c = tb[IFACE_ATTR_RA_PREF64])) {
+		const char *str = blobmsg_get_string(c);
+		char *astr = malloc(strlen(str) + 1);
+		char *delim;
+		int l;
+
+		if (!astr || !strcpy(astr, str) ||
+				(delim = strchr(astr, '/')) == NULL || (*(delim++) = 0) ||
+				sscanf(delim, "%i", &l) == 0 || l > 128 ||
+				inet_pton(AF_INET6, astr, &iface->pref64_addr) == 0)
+			iface->pref64_length = 0;
+		else
+			iface->pref64_length = l;
+
+		if (astr)
+			free(astr);
+	}
+
 	if ((c = tb[IFACE_ATTR_RA_PREFERENCE])) {
 		const char *prio = blobmsg_get_string(c);
 
--- a/src/dhcpv4.c
+++ b/src/dhcpv4.c
@@ -250,7 +250,7 @@ static int setup_dhcpv4_addresses(struct
 
 	/* Don't allocate IP range for subnets bigger than 28 */
 	if (iface->addr4[0].prefix > 28) {
-		syslog(LOG_WARNING, "Auto allocation of DHCP range fails on %s", iface->name);
+		syslog(LOG_WARNING, "Auto allocation of DHCP range fails on %s (prefix length must be < 29).", iface->name);
 		return -1;
 	}
 
--- a/src/dhcpv6-ia.c
+++ b/src/dhcpv6-ia.c
@@ -1385,7 +1385,17 @@ ssize_t dhcpv6_ia_handle_IAs(uint8_t *bu
 						a->clid_len = clid_len;
 						memcpy(a->clid_data, clid_data, clid_len);
 						a->iaid = ia->iaid;
-						a->length = reqlen;
+						if (is_pd) {
+							if (reqlen < iface->dhcpv6_pd_min) {
+								syslog(LOG_INFO, "clamping requested PD from %d to %d",
+								       reqlen, iface->dhcpv6_pd_min);
+								a->length = iface->dhcpv6_pd_min;
+							} else {
+								a->length = reqlen;
+							}
+						} else {
+							a->length = reqlen;
+						}
 						a->peer = *addr;
 						if (is_na)
 							a->assigned_host_id = l ? l->hostid : 0;
--- a/src/odhcpd.h
+++ b/src/odhcpd.h
@@ -34,6 +34,9 @@
 #define ND_OPT_RECURSIVE_DNS 25
 #define ND_OPT_DNS_SEARCH 31
 
+// RFC 8781 defines PREF64 option
+#define ND_OPT_PREF64 38
+
 #define INFINITE_VALID(x) ((x) == 0)
 
 #define _unused __attribute__((unused))
@@ -300,6 +303,8 @@ struct interface {
 	bool ra_advrouter;
 	bool ra_useleasetime;
 	bool ra_dns;
+	uint8_t pref64_length;
+	struct in6_addr pref64_addr;
 	bool no_dynamic_dhcp;
 	bool have_link_local;
 	uint8_t pio_filter_length;
@@ -345,6 +350,7 @@ struct interface {
 	bool dhcpv6_pd;
 	bool dhcpv6_na;
 	uint32_t dhcpv6_hostid_len;
+	uint32_t dhcpv6_pd_min; // minimum delegated prefix length
 
 	char *upstream;
 	size_t upstream_len;
--- a/src/router.c
+++ b/src/router.c
@@ -390,6 +390,7 @@ enum {
 	IOV_RA_ROUTES,
 	IOV_RA_DNS,
 	IOV_RA_SEARCH,
+	IOV_RA_PREF64,
 	IOV_RA_ADV_INTERVAL,
 	IOV_RA_TOTAL,
 };
@@ -427,6 +428,13 @@ struct nd_opt_route_info {
 	uint32_t addr[4];
 };
 
+struct nd_opt_pref64_info {
+	uint8_t type;
+	uint8_t len;
+	uint16_t lifetime_plc;
+	uint32_t addr[3];
+};
+
 /* Router Advert server mode */
 static int send_router_advert(struct interface *iface, const struct in6_addr *from)
 {
@@ -437,10 +445,12 @@ static int send_router_advert(struct int
 	struct nd_opt_dns_server *dns = NULL;
 	struct nd_opt_search_list *search = NULL;
 	struct nd_opt_route_info *routes = NULL;
+	struct nd_opt_pref64_info *pref64 = NULL;
 	struct nd_opt_adv_interval adv_interval;
 	struct iovec iov[IOV_RA_TOTAL];
 	struct sockaddr_in6 dest;
-	size_t dns_sz = 0, search_sz = 0, pfxs_cnt = 0, routes_cnt = 0;
+	size_t dns_sz = 0, search_sz = 0, pref64_sz = 0;
+	size_t pfxs_cnt = 0, routes_cnt = 0;
 	ssize_t valid_addr_cnt = 0, invalid_addr_cnt = 0;
 	uint32_t minvalid = UINT32_MAX, maxival, lifetime;
 	int msecs, mtu = iface->ra_mtu, hlim = iface->ra_hoplimit;
@@ -698,6 +708,62 @@ static int send_router_advert(struct int
 	iov[IOV_RA_SEARCH].iov_base = (char *)search;
 	iov[IOV_RA_SEARCH].iov_len = search_sz;
 
+	if (iface->pref64_length) {
+		/* RFC 8781 ยง 4.1 rounding up lifetime to multiply of 8 */
+		uint16_t pref64_lifetime = lifetime < (UINT16_MAX - 7) ? lifetime + 7 : UINT16_MAX;
+		uint8_t prefix_length_code = 0;
+		uint32_t mask_a1 = 0xffffffff;
+		uint32_t mask_a2 = 0xffffffff;
+
+		switch (iface->pref64_length) {
+		case 96:
+			prefix_length_code = 0;
+			break;
+		case 64:
+			prefix_length_code = 1;
+			mask_a2 = 0;
+			break;
+		case 56:
+			prefix_length_code = 2;
+			mask_a1 = htonl(0xffffff00);
+			mask_a2 = 0;
+			break;
+		case 48:
+			prefix_length_code = 3;
+			mask_a1 = htonl(0xffff0000);
+			mask_a2 = 0;
+			break;
+		case 40:
+			prefix_length_code = 4;
+			mask_a1 = htonl(0xff000000);
+			mask_a2 = 0;
+			break;
+		case 32:
+			prefix_length_code = 5;
+			mask_a1 = 0;
+			mask_a2 = 0;
+			break;
+		default:
+			syslog(LOG_WARNING, "Invalid PREF64 prefix size (%d), "
+					"ignoring ra_pref64 option!", iface->pref64_length);
+			goto pref64_out;
+			break;
+		}
+
+		pref64_sz = sizeof(*pref64);
+		pref64 = alloca(pref64_sz);
+		memset(pref64, 0, pref64_sz);
+		pref64->type = ND_OPT_PREF64;
+		pref64->len = 2;
+		pref64->lifetime_plc = htons((0xfff8 & pref64_lifetime) |
+						(0x7 & prefix_length_code));
+		pref64->addr[0] = iface->pref64_addr.s6_addr32[0];
+		pref64->addr[1] = iface->pref64_addr.s6_addr32[1] & mask_a1;
+		pref64->addr[2] = iface->pref64_addr.s6_addr32[2] & mask_a2;
+	}
+pref64_out:
+	iov[IOV_RA_PREF64].iov_base = (char *)pref64;
+	iov[IOV_RA_PREF64].iov_len = pref64_sz;
 	/*
 	 * RFC7084 ยง 4.3 :
 	 *    L-3:   An IPv6 CE router MUST advertise itself as a router for the
